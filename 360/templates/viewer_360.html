<!DOCTYPE html>
<html lang="en">

<head>
    <title>360&deg; Orientation Viewer</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <!-- Using r160 for modern features -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
    <style>
        body {
            margin: 0;
            background-color: #0d0d0d;
            overflow: hidden;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }

        #container {
            width: 100vw;
            height: 100vh;
            cursor: move;
        }

        #overlay {
            position: absolute;
            top: 30px;
            left: 30px;
            color: white;
            background: rgba(20, 20, 20, 0.95);
            padding: 20px;
            border-radius: 12px;
            z-index: 100;
            pointer-events: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 220px;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            user-select: none;
            margin-bottom: 20px;
            padding: 5px 0;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: #333;
            border-radius: 26px;
            transition: 0.3s;
        }

        .toggle-switch:after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            top: 3px;
            left: 3px;
            transition: 0.3s;
        }

        input:checked+.toggle-switch {
            background: #f2b411;
        }

        input:checked+.toggle-switch:after {
            transform: translateX(24px);
        }

        input {
            display: none;
        }

        #mode-label {
            font-weight: 800;
            font-size: 0.75rem;
            letter-spacing: 1px;
            color: #888;
            margin-bottom: 5px;
            display: block;
        }

        #mode-status {
            font-size: 1.1rem;
            font-weight: 700;
            color: #fff;
            margin-bottom: 15px;
            display: block;
        }

        .stats {
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 15px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .stat-label {
            color: #aaa;
        }

        .stat-value {
            font-weight: 700;
            font-family: monospace;
            color: #f2b411;
        }

        .help-text {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.85rem;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 15px;
            border-radius: 20px;
            pointer-events: none;
        }

        .source-link {
            display: inline-block;
            margin-top: 14px;
            text-decoration: none;
            color: #111;
            background: #f2b411;
            border-radius: 8px;
            padding: 8px 10px;
            font-weight: 700;
            font-size: 0.86rem;
        }

        .source-link:hover {
            filter: brightness(0.95);
        }

        .next-btn {
            display: inline-block;
            margin-top: 10px;
            border: 0;
            border-radius: 8px;
            padding: 8px 10px;
            font-weight: 700;
            font-size: 0.86rem;
            color: #fff;
            background: #2a2a2a;
            cursor: pointer;
        }

        .next-btn:hover:not(:disabled) {
            background: #3b3b3b;
        }

        .next-btn:disabled {
            opacity: 0.65;
            cursor: wait;
        }

        .back-btn {
            margin-top: 10px;
            background: #1f2b36;
        }

        .back-btn:hover {
            background: #2d3f4f;
        }

        .review-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .action-btn {
            border: 0;
            border-radius: 8px;
            padding: 8px 10px;
            font-weight: 700;
            font-size: 0.82rem;
            color: #fff;
            cursor: pointer;
            flex: 1 1 auto;
        }

        .pass-btn {
            background: #1f8f5f;
        }

        .pass-btn:hover:not(:disabled) {
            background: #26a36c;
        }

        .fail-btn {
            background: #b33b2b;
        }

        .fail-btn:hover:not(:disabled) {
            background: #cc4734;
        }

        .action-btn:disabled {
            opacity: 0.65;
            cursor: wait;
        }

        .review-stats {
            margin-top: 8px;
            font-size: 0.78rem;
            color: #b9b9b9;
            letter-spacing: 0.2px;
        }
    </style>
</head>

<body>
    <div id="overlay">
        <span id="mode-label">VIEWING MODE</span>
        <span id="mode-status">Original View</span>

        <label class="toggle-container">
            <span style="font-weight: 600;">Enable Leveling</span>
            <input type="checkbox" id="toggleCorrection" checked>
            <div class="toggle-switch"></div>
        </label>
        <label class="toggle-container">
            <span style="font-weight: 600;">Preload Next Random</span>
            <input type="checkbox" id="togglePreloading">
            <div class="toggle-switch"></div>
        </label>

        <div class="stats">
            <div class="stat-item">
                <span class="stat-label">Pitch:</span>
                <span class="stat-value" id="p-val">0.00&deg;</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Roll:</span>
                <span class="stat-value" id="r-val">0.00&deg;</span>
            </div>
        </div>

        <button id="backToStartBtn" class="next-btn back-btn" type="button">Back to Start Page</button>
        <button id="nextSampleBtn" class="next-btn" type="button">Next Random Sample</button>
        <div class="review-actions">
            <button id="passBtn" class="action-btn pass-btn" type="button">Pass + Next</button>
            <button id="failBtn" class="action-btn fail-btn" type="button">Fail + Next</button>
        </div>
        <div id="reviewStats" class="review-stats">Pass: 0 (0.0%) | Fail: 0 (0.0%) | Total: 0</div>
        <a id="panoramaxLink" class="source-link" href="#" target="_blank" rel="noopener noreferrer" style="display:none;">View on Panoramax</a>
    </div>

    <div class="help-text">
        Drag to Orbit &bull; Scroll to Zoom
    </div>

    <div id="container"></div>

    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const settings = {
            sample_count: parseInt(urlParams.get('sample_count') || '36', 10),
            fov: parseFloat(urlParams.get('fov') || '60'),
            inlier_threshold_deg: parseFloat(urlParams.get('inlier_threshold_deg') || '2')
        };
        let currentImageSrc = urlParams.get('img');
        let currentPitch = parseFloat(urlParams.get('pitch') || 0);
        let currentRoll = parseFloat(urlParams.get('roll') || 0);
        let currentPanoramaxPic = (urlParams.get('panoramax_pic') || '').trim().toLowerCase();
        let nextSamplePromise = null;
        let cachedNextSample = null;
        let preloadingEnabled = false;
        let passCount = 0;
        let failCount = 0;
        let isAdvancing = false;

        let camera, scene, renderer, sphere, correctionGroup, textureLoader;
        let isUserInteracting = false, lon = 0, lat = 0, phi = 0, theta = 0;
        let onPointerDownMouseX = 0, onPointerDownMouseY = 0, onPointerDownLon = 0, onPointerDownLat = 0;

        init();
        updateStatsAndLink();
        queueNextSamplePreload();

        function init() {
            const container = document.getElementById('container');

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1100);

            // Correction group allows us to tilt the entire environment
            correctionGroup = new THREE.Group();
            scene.add(correctionGroup);

            // Sphere geometry for equirectangular projection
            const geometry = new THREE.SphereGeometry(500, 60, 40);
            geometry.scale(-1, 1, 1); // Invert to see from inside

            textureLoader = new THREE.TextureLoader();
            const texture = textureLoader.load(currentImageSrc, function (tex) {
                tex.colorSpace = THREE.SRGBColorSpace;
                renderer.render(scene, camera);
            });

            const material = new THREE.MeshBasicMaterial({ map: texture });
            sphere = new THREE.Mesh(geometry, material);
            correctionGroup.add(sphere);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setAnimationLoop(animate);
            container.appendChild(renderer.domElement);

            container.style.touchAction = 'none';
            container.addEventListener('pointerdown', onPointerDown);
            document.addEventListener('wheel', onDocumentMouseWheel);
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onPointerDown(event) {
            if (event.isPrimary === false) return;
            isUserInteracting = true;
            onPointerDownMouseX = event.clientX;
            onPointerDownMouseY = event.clientY;
            onPointerDownLon = lon;
            onPointerDownLat = lat;
            document.addEventListener('pointermove', onPointerMove);
            document.addEventListener('pointerup', onPointerUp);
        }

        function onPointerMove(event) {
            if (event.isPrimary === false) return;
            if (isUserInteracting === true) {
                lon = (onPointerDownMouseX - event.clientX) * 0.1 + onPointerDownLon;
                lat = (event.clientY - onPointerDownMouseY) * 0.1 + onPointerDownLat;
            }
        }

        function onPointerUp(event) {
            if (event.isPrimary === false) return;
            isUserInteracting = false;
            document.removeEventListener('pointermove', onPointerMove);
            document.removeEventListener('pointerup', onPointerUp);
        }

        function onDocumentMouseWheel(event) {
            const fov = camera.fov + event.deltaY * 0.05;
            camera.fov = THREE.MathUtils.clamp(fov, 10, 85);
            camera.updateProjectionMatrix();
        }

        function animate() {
            lat = Math.max(-85, Math.min(85, lat));
            phi = THREE.MathUtils.degToRad(90 - lat);
            theta = THREE.MathUtils.degToRad(lon);

            const x = 500 * Math.sin(phi) * Math.cos(theta);
            const y = 500 * Math.cos(phi);
            const z = 500 * Math.sin(phi) * Math.sin(theta);

            camera.lookAt(x, y, z);
            renderer.render(scene, camera);
        }

        function updateStatsAndLink() {
            document.getElementById('p-val').textContent = currentPitch.toFixed(2) + '\u00B0';
            document.getElementById('r-val').textContent = currentRoll.toFixed(2) + '\u00B0';
            const panoramaxLink = document.getElementById('panoramaxLink');
            if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/.test(currentPanoramaxPic)) {
                panoramaxLink.href = `https://api.panoramax.xyz/#focus=pic&pic=${encodeURIComponent(currentPanoramaxPic)}`;
                panoramaxLink.style.display = 'inline-block';
            } else {
                panoramaxLink.style.display = 'none';
                panoramaxLink.href = '#';
            }
        }

        function applyCorrection() {
            const isChecked = document.getElementById('toggleCorrection').checked;
            const status = document.getElementById('mode-status');
            if (isChecked) {
                status.textContent = "Leveled View";
                status.style.color = "#f2b411";
                // Correct Axis Mapping: 
                // X-axis is Front-Back orientation in this Three.js setup -> Roll
                // Z-axis is Right-Left orientation -> Pitch
                // User reported Roll was still swapped
                correctionGroup.rotation.x = THREE.MathUtils.degToRad(-currentRoll);
                correctionGroup.rotation.z = THREE.MathUtils.degToRad(currentPitch);
            } else {
                status.textContent = "Original View";
                status.style.color = "#fff";
                correctionGroup.rotation.x = 0;
                correctionGroup.rotation.z = 0;
            }
        }

        function loadTexture(url) {
            return new Promise((resolve, reject) => {
                textureLoader.load(
                    url,
                    (tex) => {
                        tex.colorSpace = THREE.SRGBColorSpace;
                        resolve(tex);
                    },
                    undefined,
                    reject
                );
            });
        }

        async function applySample(sample) {
            const newTexture = await loadTexture(sample.imageSrc);
            const oldTexture = sphere.material.map;
            sphere.material.map = newTexture;
            sphere.material.needsUpdate = true;
            if (oldTexture) oldTexture.dispose();

            currentImageSrc = sample.imageSrc;
            currentPitch = sample.pitch;
            currentRoll = sample.roll;
            currentPanoramaxPic = sample.panoramaxPic || '';
            updateStatsAndLink();
            applyCorrection();
        }

        async function fetchPredictedRandomSample() {
            const idResponse = await fetch('/api/random_id');
            const idData = await idResponse.json();
            if (!idData.id) throw new Error(idData.error || 'Failed to get random Panoramax ID');

            const picId = String(idData.id).toLowerCase();
            const imageUrl = `https://api.panoramax.xyz/api/pictures/${picId}/hd.jpg`;
            const formData = new FormData();
            formData.append('url', imageUrl);
            formData.append('sample_count', String(settings.sample_count));
            formData.append('fov', String(settings.fov));
            formData.append('inlier_threshold_deg', String(settings.inlier_threshold_deg));

            const predictResponse = await fetch('/api/predict_360', {
                method: 'POST',
                body: formData
            });
            const predictData = await predictResponse.json();
            if (predictData.status !== 'success') {
                throw new Error(predictData.error || 'Failed to process random sample');
            }

            const sample = {
                imageSrc: `/mem_image/${predictData.main_id}`,
                pitch: Number(predictData.pitch || 0),
                roll: Number(predictData.roll || 0),
                panoramaxPic: picId
            };
            try {
                await fetch(sample.imageSrc, { cache: 'force-cache' });
            } catch (err) {
                console.warn('Image prefetch failed, continuing with prepared sample.', err);
            }
            return sample;
        }

        function queueNextSamplePreload() {
            if (!preloadingEnabled) return;
            if (cachedNextSample || nextSamplePromise) return;
            nextSamplePromise = fetchPredictedRandomSample()
                .then((sample) => {
                    if (!preloadingEnabled) return null;
                    cachedNextSample = sample;
                    return sample;
                })
                .catch((err) => {
                    console.error(err);
                    return null;
                })
                .finally(() => {
                    nextSamplePromise = null;
                });
        }

        async function consumeNextSample() {
            if (cachedNextSample) {
                const sample = cachedNextSample;
                cachedNextSample = null;
                return sample;
            }
            if (!preloadingEnabled) {
                return await fetchPredictedRandomSample();
            }
            if (!nextSamplePromise) {
                queueNextSamplePreload();
            }
            const sample = await nextSamplePromise;
            if (!sample) throw new Error('Random sample preload failed');
            cachedNextSample = null;
            return sample;
        }

        function updateReviewStats() {
            const total = passCount + failCount;
            const passPct = total > 0 ? (passCount / total) * 100 : 0;
            const failPct = total > 0 ? (failCount / total) * 100 : 0;
            document.getElementById('reviewStats').textContent =
                `Pass: ${passCount} (${passPct.toFixed(1)}%) | Fail: ${failCount} (${failPct.toFixed(1)}%) | Total: ${total}`;
        }

        function setAdvanceLoadingState(isLoading, label) {
            document.getElementById('nextSampleBtn').disabled = isLoading;
            document.getElementById('passBtn').disabled = isLoading;
            document.getElementById('failBtn').disabled = isLoading;
            document.getElementById('nextSampleBtn').textContent = isLoading ? (label || 'Loading Next...') : 'Next Random Sample';
        }

        async function goToNextSample(decision) {
            if (isAdvancing) return;
            isAdvancing = true;
            setAdvanceLoadingState(true, 'Loading Next...');
            try {
                if (decision === 'pass') {
                    passCount += 1;
                    updateReviewStats();
                } else if (decision === 'fail') {
                    failCount += 1;
                    updateReviewStats();
                }
                const sample = await consumeNextSample();
                await applySample(sample);
                queueNextSamplePreload();
            } catch (err) {
                console.error(err);
                alert(err.message || 'Failed to load the next random sample');
                queueNextSamplePreload();
            } finally {
                setAdvanceLoadingState(false);
                isAdvancing = false;
            }
        }

        document.getElementById('toggleCorrection').addEventListener('change', function () {
            applyCorrection();
        });

        document.getElementById('togglePreloading').addEventListener('change', function (e) {
            preloadingEnabled = e.target.checked;
            if (!preloadingEnabled) {
                cachedNextSample = null;
            } else {
                queueNextSamplePreload();
            }
        });

        document.getElementById('backToStartBtn').addEventListener('click', function () {
            window.location.href = '/predict_360';
        });

        document.getElementById('nextSampleBtn').addEventListener('click', async function () {
            await goToNextSample(null);
        });

        document.getElementById('passBtn').addEventListener('click', async function () {
            await goToNextSample('pass');
        });

        document.getElementById('failBtn').addEventListener('click', async function () {
            await goToNextSample('fail');
        });

        document.getElementById('togglePreloading').dispatchEvent(new Event('change'));
        updateReviewStats();
        document.getElementById('toggleCorrection').dispatchEvent(new Event('change'));
    </script>
</body>

</html>
